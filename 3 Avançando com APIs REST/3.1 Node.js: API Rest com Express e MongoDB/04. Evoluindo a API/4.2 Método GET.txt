[00:00] Na aula anterior começamos a ver a questão da conexão com o banco para obter uma lista de livros que estavam no banco, no nosso caso tinha apenas um e ele foi demonstrado corretamente no Postman. Vamos continuar fazendo isso agora só que vamos evoluir um pouco a nossa arquitetura separando ela em camadas.

[00:22] Eu não vou deixar aqui dentro do "app.js" todas essas requisições, todo esse get, post e put vamos usar um padrão de projeto que é o controller. Vamos criar uma pasta com o controllers, eu vou criar um controlador que vai ser o intermediário entre o que vem de requisição do que chamamos de view, que é a camada de apresentação, pode ser do front-end, de outra API ou do Postman, que é o caso que estamos testando aqui, e o banco de dados. O controlador é um intermediário, ele recebe as requisições e vai devolver as respostas.

[01:01] Vamos começar criando essa pasta aqui dentro de "src", eu vou criar uma nova pasta chamada "controllers" e eu vou criar um arquivo chamado "livrosController.js" e vamos começar a organizar, tirar um pouco de código do “app.js”.

[01:30] O “app.js” no final do nosso projeto vai está limpo, com pouca informação, assim como o Server que só escuta em que porta que ele vai agir, em que ele vai subir o servidor, o app também vai está bem enxuto e bem fácil de você entender com uma boa legibilidade. Vamos concentrar o que é referente ao controlador no arquivo de controlador, o que é referente a definição das rotas no arquivo de rotas, vamos construindo passo a passo.

[02:04] Aqui eu vou fazer a importação do meu livro, do modelo livro, exatamente como eu estava fazendo no app. Eu vou fazer um import livro from "../models/Livro.js";, coloque o .js como boa prática para ficar registrado e aí eu vou criar aqui uma classe chamada LivroController e vou colocar os métodos aqui dentro para que fique em uma organização melhor, nesse conceito de classe. E eu vou criar os métodos no tipo estático para que não precisemos instanciar essa classe.

[02:45] Vou criar aqui class LivroController { e eu já vou incluir o final aqui que é a exportação export default LivroCrontroller, porque vamos querer usar esse controlador lá nas rotas para definir em que método ele tem que chegar dada a rota que for pedida no end point. Basicamente vai ser essa a dinâmica, vamos ter um arquivo de rotas definindo para cada get, post, put ou o que for pedir qual é a rota que ele deve chamar, qual é o método que ele deve chamar.

[03:28] Aqui vamos fazer exatamente o que tínhamos feito lá no “app.js”, eu vou pegar aquele método get e vou alterar aqui com o que eu preciso fazer. Só que aqui eu vou usar um nome intuitivo, eu não vou usar um nome como get eu vou dizer que eu quero obter todos os livros, esse é o nome que eu vou usar aqui para o meu método.

[03:55] Vou colocá-lo como static listarLivros e aí fica a seu critério também como você achar melhor e aqui como estou criando um método eu vou passar a requisição e a resposta nesse formato aqui como parâmetro para esse método, requisição e resposta e vou usar aqui a arrow function conhecida, static listarLitros = (req, res) => { } e programar o que tem que acontecer aqui no meu método.

[04:34] Para isso eu vou copiar o que tínhamos feito aqui no “app.js”, esse get livros onde eu tinha o livros.find eu vou copiar exatamente essa linha e vou colar no “livroController.js”, class LivroController { static listarLivros = (req, res) => { livros.find((err, livros) => { res.status(200).json(livros) }. Aqui dentro ele vai achar o livros.find e eu vou fechar o parênteses. Esse do “app.js” vamos apagar, não quero mais esse get aqui vamos removê-lo daqui para ter certeza que ele só está caindo aqui no “livroController.js”. É basicamente a mesma coisa, método vai ser listarLivros eu vou passar uma requisição e uma resposta e vou pedir para ele localizar nos livros todos os livros que ele tiver e devolver um status(200), devolvendo esse livro em formato Json.

[05:49] Inicialmente a nossa classe LivroController está certinha aqui, eu já tenho um método e agora vamos usar esse método no arquivo de rotas, precisamos de um arquivo de rotas porque aqui eu não tenho mais nenhuma referência qual é o método. Eu não sei se é a requisição get, put, eu não falei nada eu só falei que eu quero listarLivros. O que está programado quando eu pedir para listar livros? Eu não tenho nenhuma referência aqui com o tipo da requisição, essa referência vai acontecer vai acontecer no arquivo de rotas.

[06:27] Vamos criar também dentro de "src", uma pasta chamada "routes" que eu vou colocar as rotas e dentro dessa pasta vou criar um arquivo chamado “livrosRoutes.js”, só para manter a boa prática. Vamos começar a programar, esse arquivo de rotas vai precisar do Express porque precisamos usá-lo aqui, é ele que vai fazer essa conexão aqui com o get, com o que precisa fazer. Vamos copiar esse import express from "express"; e eu vou precisar também do livrosController, eu vou importar import LivroController from "../controllers/livrosController.js";, coloquei aqui também como js de boa prática para mantê-lo aqui.

[07:49] E eu vou criar uma constante chamado router onde eu vou usar o roteamento do express, const router = express.Router();. Definimos as rotas uma vez que foi criada essa variável para utilizar colocando o router e se você colocar esses dois pontos você consegue programar o que vai acontecer na rota. Dessa rota se acontecer um .get("/livros") que já usávamos e o segundo parâmetro é o que tem que acontecer quando for chamada a rota do get, vamos usar LivroController.listarLivros, isso que tem que acontecer.

[08:56] O nosso roteamento já está correto, já está certo o que precisa acontecer eu já exportei, já defini o que eu vou fazer e agora basta eu exportar para usar isso em outro ponto, export default router;. A parte de controlador eu defino a implementação mesmo do método e o arquivo de router que é o das rotas eu defino o que vai acontecer a cada rota, eu concentro aqui tudo o que vai acontecer baseado na requisição e no parâmetro da rota.

[09:51] Vamos avançar aqui agora, esse arquivo de rotas vamos chamá-lo no "app.js", como eu falei daqui a pouco esse "app.js" vai está bem enxuto porque todos os métodos vão estar nos seus devidos lugares, a implementação no controller e o que for pertinente a rota vai estar aqui no roteador. Antes disso, só para não termos que importar depois vários arquivos referentes a rotas, vamos criar um arquivo chamado "index.js" que é onde eu vou concentrar todas as rotas que eu for utilizar na aplicação de livro, de autor, de editora, vamos centralizar ali para ficar melhor organizado.

[10:37] Dentro de "routes" eu vou criar um novo arquivo chamado "index.js" e nesse arquivo também vamos usar o express e o que for preciso, todas as rotas que formos utilizar, a "livrosRoutes", a "autorRoutes", "editorasRoutes", cada rota que eu tiver eu vou indicar aqui.

[11:02] Vamos importar o express import express from "express";, vamos importar a livrosRoutes, import livros from "./livrosRoutes.js" e aqui vamos criar as nossas rotas, como o conjunto de todas as rotas que vamos usar. Eu vou chamar aqui const routes e quando eu for usar isso no “app.js” eu vou passar um parâmetro que é o que vai chegar aqui nas minhas rotas e vai chegar um próprio app, const routes = (app).

[12:02] A própria aplicação eu vou mandar uma instância para cá para usar o que estiver de rotas aqui. Vamos criar a arrow function e aí eu vou programar aqui não só a rota de livros, mas também aquela rota inicial, aquela que dávamos a mensagem Curso de Node, por exemplo. Para fazer isso chamamos o app, que é o parâmetro que chegou e uso o método app.route(‘/’) e eu digo que se chegar sem nada, porque eu não vou ter um controlador, um arquivo de rotas só para esse caso aqui, isso eu posso colocar aqui dentro do "index.js", não tem problema.

[12:48] Para os outros que eu tenho mais coisas a fazer aí separamos por arquivo, mas esse que é só uma mensagem inicial podemos colocar aqui mesmo. Eu coloco que se chegar no caminho inicial que é o localhost:3000 eu vou fazer um get passando a requisição e resposta app.route('/ ').get((req, res) => { e o que vai chegar aqui, para esse caso, eu devolvo como status(200) como já devolvemos e vai mandar aquele Curso de Node que tinha lá, res.status(200).send({titulo: "Curso de node"}).

[13:47] Essa primeira rota aqui eu fiz, quando eu chegar no diretório comum que é no end point padrão que é “localhost:3000” ele vai entender que vai está chegando aqui e aí dado uma requisição e resposta eu vou devolver na resposta esse Json com o título e "Curso de node" escrito.

[14:10] Para os outros casos vamos fazer um app.use( para usar as outras rotas. Eu quero usar a rota de livros, eu quero indicar que eu vou trabalhar com Json, eu vou passar aquele parâmetro que também usamos no app que é o express.json(), e eu vou separando com virgulas. Aqui eu só tenho livros, eu vou passar o livros aqui e depois disso eu vou fazer um exporte desse arquivo “index.js”, export default routes.

[14:55] Esse arquivo index está pronto, já tenho a rota principal e estou falando com ele que eu tenho uma rota disponível que é a rota de livros, tudo o que for passado procura aqui também na rota de livros para ver o que você deve fazer. Isso é um direcionamento, um caminho para onde tem que seguir dado o end poist que você passar.

[15:19] Dado aquele endereço que você mandou no Postman ele vai conseguir se entender aqui e ver para onde ele tem que ir, aonde ele tem que procurar para chegar no método que precisamos executar, que no caso é devolver a lista de livros.

[15:35] Vamos acertar agora aqui no nosso “app.js” e vamos passar a importar aqui também o arquivo de rotas, vamos importar esse arquivo “index.js”. Vou fazer o import routes from "./routes/index.js" e eu vou usar essa rota. Aqui em baixo vou chamar o routes e vou passar o app que eu instanciei aqui para lá, routes(app);, com isso ele já tem que conseguir obter os livros lá exatamente como ele obtinha antes.

[16:30] Eu vou até apagar aqui esse "Curso de node" porque não precisamos mais dele aqui no “app.js”, uma vez que eu já o inclui no “index.js” e vou deixar aqui só os métodos que estão pendentes porque aos poucos vamos retirar todos eles daqui e aí no “app.js” vai ficar legível e só com o que ele realmente precisa conter.

[16:52] Vamos testar lá no Postman, aqui se eu fizer esse Get “/livros” ele vai continuar funcionando porque eu só mudei o método de lugar, passei uma rota e o que tinha que acontecer e passei exatamente o mesmo método para lá, e se eu chamar “/3000” ele também vai continuar funcionando aqui, dessa vez mandando "Curso de node".

[17:18] Aos poucos fomos separando os nossos arquivos e pastas de acordo com a funcionalidade e esse geralmente é o padrão que usamos. Aqui precisamos ir introduzindo os conceitos primeiro porque o foco era entender o que era cada tipo de requisição, o que é um get, o que é um post, fomos fazendo no mesmo arquivo, mas o correto quando você vai começar um projeto é já fazer separado, já fazer no seu arquivo correto. Quando você já tem uma prática você já vai fazendo exatamente do jeito que vamos concluir aqui.

[17:57] Na próxima aula vamos fazer o post e ver a persistência de dados no Mongo e a recuperação já nesse padrão novo que estamos usando aqui de arquitetura. Espero por vocês.